1. 다형성 (Polymorphism) 
    1) 여러 개의 서로 다른 객체가 동일한 기능을 서로 다른 방법으로 
       처리할 수 있는 기능을 의미함.
       - 예) 게임 프로그램에서 공격하다(attack()) 기능을 
             칼, 대포, 총 등의 무기들은 공통적으로 '공격'이라는 동일한 기능을 수행함

2. 가상 함수와 오버라이딩 
    1) 가상 함수 (virtual function)
        - virtual 키워드로 선언된 멤버 함수 
        - virtual 키워드
            - 동적 바인딩 지시어 
            - 컴파일러에게 함수에 대한 호출 바인딩을 실행 시간까지 미루도록 지시 
    2) 함수 오버라이딩(function overriding)
        - 파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수 선언 
        - 파생 클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩
        - 함수 재정의
        - 다형성의 한 종류     

3. 동적 바인딩
    1) 자식 클래스에 대해 기본(부모) 클래스에 대한 포인터로 가상 함수를 
       호출하는 경우, 객체 내 오버라이딩한 파생 클래스의 함수를 찾아 실행하는 것.
    2) 실행 중에 이루어짐 
        - 실행시간 바인딩, 런타임 바인딩, 늦은 바인딩

4. 오버라이딩 특징
    1) 가상 함수 이름, 매개변수 타입과 개수, 리턴 타입이 모두 일치 
    2) 오버라이딩 시 virtual 지시어 생략 가능
        - 가상 함수의 virtual 지시어는 상속됨.
        - 파생 클래스에서 virtual 생략 가능     

5. 가상 소멸자 
    1) 소멸자를 virtual 키워드로 선언
    2) 소멸자 호출시 동적 바인딩 발생 
        - 자식 클래스의 소멸자가 자신의 코드 실행 후,
          기본 클래스의 소멸자를 호출하도록 컴파일됨.    
    3) 상속 관계가 있을때 메모리 해제 해야 하는 경우
       반드시 부모 클래스의 소멸자를 가상 함수로 선언해야 함       

6. 오버로딩 vs 오버라이딩 
    1) 오버로딩 (Overloading, 함수의 중복 정의)
        - 함수 이름은 같지만, 매개변수이 타입이나 개수가 다르면 다른 함수로 간주함
        - 예)
            void fun(int x);
            void fun(char c);
            void fun(float c);
            void fun(int x, int y);

    2) 오버라이딩(Overriding, 함수의 재정의)
        - 함수의 원형이 완벽히 일치하는 함수의 정의 부분을 재정의함 
        - 상속에서만 사용가능함
            - 부모 클래스의 함수를 재정의해서 사용함 
        - 예)
            void fun(int x)
            {
                정의 부분1
            }         
            void fun(int x)
            {
                정의 부분2
            }                         

7. 순수 가상 함수
    1) 부모(기본) 클래스의 가상 함수 목적 
        - 자식(파생) 클래스에서 재정의할 함수를 알려주는 역할 
        - 실행할 코드를 작성할 목적이 아님 
            - ==> 기본 클래스의 가상 함수를 굳이 구현할 필요가 없음.

    2) 순수 가상 함수(pure virtual function)
        - 함수의 코드가 없고 선언만 있는 가상 멤버 함수 
        - 멤버 함수의 원형 = 0;으로 선언

8. 추상 클래스 
    1) 최소한 하나의 순수 가상 함수를 가진 클래스 
        - 추상 클래스의 모든 멤버 함수를 순수 가상 함수로 선언할 필요 없음
    2) 온전한 클래스가 아니므로 객체 생성 불가능 
    3) 목적 
        - 추상 클래스의 인스턴스를 생성할 목적 아님
        - 상속에서 기본 클래스의 역할을 하기 위함 
            - 자식 클래스에서 구현할 함수의 원형을 보여주는 인터페이스 역할 
            - 설계 단계 사용용


9. 정리                                                                
    1) 포인터 변수로 객체에 접근할 때 C++ 컴파일러는 포인터 변수가 가리키고 있는
       변수의 타입을 기준으로 함수를 호출함 
        - 일반적인 함수의 정적 바인딩    
            - A라는 객체를 가리키는 포인터 변수는 A 객체의 멤버 함수만을 호출할수 있음.

    2) 가상 함수(Virtual Function)란 자식 클래스에서 재정의 할수 있는 멤버 함수임.
        - Virtual 키워드를 이용해 가상 함수를 선언 할 수 있음
        - 자식 클래스에서 가상 함수를 재정의하면, 재정의된 멤버 함수를 호출함 
            - 동적 바인딩    

    3) 동적 바인딩
        - C++는 특정한 함수를 호출할 때 해당 함수의 루틴이 기록된 메모리 주소를 
          알아야 함.
        - 특정한 함수를 호출하는 소스코드에서 실제 함수가 정의된 메모리 공간을 찾기
          위해서는 바인딩(Binding) 과정이 필요함.
          - 일반적으로 함수의 호출은 컴파일 시기에 고정된 메모리 주소를 이용함 
                - 이러한 방식을 정적 바인딩(Static Binding)이라고 함.
                - C++ 일반적인 멤버함수는 모두 이러한 정적 바인딩 사용함.
          - 가상 함수는 프로그램이 실행될 때 객체를 결정한다는 점에서 
            컴파일 시간에 객체를 특정할 수 없음.
                - 가상 함수는 실행 시간 때 올바른 함수가 실행될 수 있도록 
                  동적 바인딩(Dynamic Binding)을 사용함.
    4) 순수 가상 함수
        - 가상 함수는 기본적으로 반드시 재정의할 필요는 없음.
        - 순수 가상 함수는 자식 클래스에서 반드시 재정의를 해주어야 하는 함수임.                  
        - 일반적으로 순수 가상 함수는 부모 클래스에서 함수 동작의 본체를 정의하지 않음.
            - 자식 클래스에서 반드시 이를 정의해야 사용할수 있음.
            - 순수 가상 함수는 =0 키워드를 붙여서 선언할 수 있음.